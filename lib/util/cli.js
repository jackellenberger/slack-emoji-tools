const _ = require('lodash');

const logger = require('../logger');

function list(val, memo) {
  memo = memo || [];
  memo.push(val === '' ? null : val);
  return memo;
}

function verbosity() {
  logger.transports[0].level = 'debug';
}

function requireAuth(program) {
  return program
    .option('-s, --subdomain <value>', 'slack subdomain. Can be specified multiple times, paired with respective token.', list, [])
    .option('-d, --domain <value>', 'alias for --subdomain', list, [])
    .option('-t, --token <value>', 'slack cookie token. ususaly starts xoxc-... Can be specified multiple times, paired with respective subdomains. User tokens (xoxs-...) are no longer supported.', list, [])
    .option('-c, --cookie <value>', 'slack cookie. ususaly starts xox*-... Can be specified multiple times, paired with respective subdomains.', list, [])
    .option('-a --auth-json <value>', 'A json-string containing keys "domain", "token", and "cookie", as generated by the Emojme: Emoji Anywhere Chrome Extension', list, []);
}

function allowEmojiAlterations(program) {
  return program
    .option('--allow-collisions', 'do not cull collisions ever, upload everything just as it is and accept the collisions. This will be faster for known-good uploads, more rate-limiting prone for untrusted uploads.', false)
    .option('--avoid-collisions', 'instead of culling collisions, rename the emoji to be uploaded "intelligently"', false)
    .option('--prefix <value>', 'prefix all emoji to be uploaded with <value>');
}

function allowIoControl(program) {
  return program
    .option('--bust-cache', 'force a redownload of all cached info.', false)
    .option('--no-output', 'prevent writing of files in build/ and log/')
    .option('--since <value>', 'only consider emoji since the given epoch timestamp')
    .option('--verbose', 'log debug messages to console', verbosity);
}

function unpackAuthJson(program) {
  // Take a commander program, and if an authJson is included, split it into
  // constituent subdomain, token, and cookies
  if (!program.authJson || _.isEmpty(program.authJson)) {
    return;
  }

  _.each(program.authJson, (authJson) => {
    const auth = JSON.parse(authJson);

    if ((auth.domain || auth.subdomain) && auth.token && auth.cookie) {
      program.subdomain.push(auth.domain || auth.subdomain);
      program.token.push(auth.token);
      program.cookie.push(auth.cookie);
    }
  });
}

module.exports = {
  list,
  requireAuth,
  allowIoControl,
  allowEmojiAlterations,
  unpackAuthJson,
};
